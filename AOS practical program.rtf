{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fmodern\fprq1\fcharset0 Consolas;}{\f1\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\widctlpar\sl240\slmult1\f0\fs21\lang16393 Q\par
// display a given message 'n' times \par
\par
#include <stdio.h>\par
#include <setjmp.h>\par
\par
// Global variables\par
jmp_buf jumpBuffer;\par
\par
void printMessage(int n, const char* message) \{\par
\~ \~ if (n <= 0) \{\par
\~ \~ \~ \~ // Return to the setjmp point\par
\~ \~ \~ \~ longjmp(jumpBuffer, 1);\par
\~ \~ \}\par
\par
\~ \~ printf("%s\\n", message);\par
\par
\~ \~ // Decrement n and recursively call printMessage\par
\~ \~ printMessage(n - 1, message);\par
\}\par
\par
int main() \{\par
\~ \~ // Setjmp point\par
\~ \~ if (setjmp(jumpBuffer) == 0) \{\par
\~ \~ \~ \~ // Prompt user for input\par
\~ \~ \~ \~ int n;\par
\~ \~ \~ \~ printf("Enter the number of times to display the message: ");\par
\~ \~ \~ \~ scanf("%d", &n);\par
\par
\~ \~ \~ \~ // Clear input buffer\par
\~ \~ \~ \~ while (getchar() != '\\n');\par
\par
\~ \~ \~ \~ // Prompt user for message\par
\~ \~ \~ \~ char message[256];\par
\~ \~ \~ \~ printf("Enter the message to display: ");\par
\~ \~ \~ \~ fgets(message, sizeof(message), stdin);\par
\par
\~ \~ \~ \~ // Remove trailing newline character from message\par
\~ \~ \~ \~ message[strcspn(message, "\\n")] = '\\0';\par
\par
\~ \~ \~ \~ // Call printMessage\par
\~ \~ \~ \~ printMessage(n, message);\par
\~ \~ \}\par
\par
\~ \~ return 0;\par
\}\par

\pard\sl240\slmult1\f1\fs22\lang9 ------------------------------------------------------------------------------------------------------------------------Q\par
// blocks the SIGQUIT signal \par
\par
#include <stdio.h>\par
#include <stdlib.h>\par
#include <signal.h>\par
#include <unistd.h>\par
\par
void handleSignal(int signal) \par
\{\par
    if (signal == SIGQUIT) \{\par
        printf("Received SIGQUIT signal. Unblocking the signal.\\n");\par
        sigset_t unblockSet;\par
        sigemptyset(&unblockSet);\par
        sigaddset(&unblockSet, SIGQUIT);\par
        sigprocmask(SIG_UNBLOCK, &unblockSet, NULL);\par
    \}\par
\}\par
\par
int main() \{\par
    // Set up signal handler\par
    signal(SIGQUIT, handleSignal);\par
\par
    // Block SIGQUIT signal\par
    sigset_t blockSet;\par
    sigemptyset(&blockSet);\par
    sigaddset(&blockSet, SIGQUIT);\par
    sigprocmask(SIG_BLOCK, &blockSet, NULL);\par
\par
    printf("SIGQUIT signal is blocked for 5 seconds.\\n");\par
\par
    sleep(5);\par
\par
    // Check for pending signals\par
    sigset_t pendingSet;\par
    sigpending(&pendingSet);\par
\par
    if (sigismember(&pendingSet, SIGQUIT)) \{\par
        printf("SIGQUIT signal occurred during the blocking period.\\n");\par
        printf("Unblocking the signal.\\n");\par
        sigprocmask(SIG_UNBLOCK, &blockSet, NULL);\par
    \}\par
\par
    // Wait for another occurrence of SIGQUIT signal to terminate the program\par
    pause();\par
\par
    printf("Program terminated.\\n");\par
\par
    return 0;\par
\}\par
//press Ctrl+\\ (SIGQUIT), the program will unblock the signal. If you press Ctrl+\\ again, the program will terminate. \par
------------------------------------------------------------------------------------------------------------------------\par
Q\par
//reads the contents of the current directory  displays names ,count of files\par
#include <stdio.h>\par
#include <dirent.h>\par
\par
int main() \{\par
    DIR *dir;\par
    struct dirent *entry;\par
    int fileCount = 0;\par
    int dirCount = 0;\par
\par
    // Open the current directory\par
    dir = opendir(".");\par
\par
    if (dir == NULL) \{\par
        printf("Error opening the directory.\\n");\par
        return 1;\par
    \}\par
\par
    // Read directory entries\par
    while ((entry = readdir(dir)) != NULL) \{\par
        if (entry->d_type == DT_REG) \{\par
            // Entry is a file\par
            printf("{{\field{\*\fldinst{HYPERLINK File: %s\\\\n }}{\fldrslt{File: %s\\n\ul0\cf0}}}}\f1\fs22 ", entry->d_name);\par
            fileCount++;\par
        \} else if (entry->d_type == DT_DIR) \{\par
            // Entry is a subdirectory\par
            printf("Directory: %s\\n", entry->d_name);\par
            dirCount++;\par
        \}\par
    \}\par
\par
    // Close the directory\par
    closedir(dir);\par
\par
    printf("Total files: %d\\n", fileCount);\par
    printf("Total directories: %d\\n", dirCount);\par
\par
    return 0;\par
\}\par
------------------------------------------------------------------------------------------------------------------------\par
Q\par
//multiple files as command line arguments and prints their sizes:\par
\par
#include <stdio.h>\par
\par
int main(int argc, char *argv[]) \{\par
    // Iterate through the command line arguments\par
    for (int i = 1; i < argc; i++) \{\par
        FILE *file = fopen(argv[i], "r");\par
        if (file == NULL) \{\par
            printf("Unable to open file: %s\\n", argv[i]);\par
        \} else \{\par
            // Move the file pointer to the end to get the size\par
            fseek(file, 0, SEEK_END);\par
            long size = ftell(file);\par
            fclose(file);\par
            printf("{{\field{\*\fldinst{HYPERLINK File: %s, Size: %ld bytes\\\\n }}{\fldrslt{File: %s, Size: %ld bytes\\n\ul0\cf0}}}}\f1\fs22 ", argv[i], size);\par
        \}\par
    \}\par
\par
    return 0;\par
\}\par
//You can run this program and provide the file names as comman\par
------------------------------------------------------------------------------------------------------------------------\par
Q\par
//last access and modified time of a given file\par
#include <stdio.h>\par
#include <stdlib.h>\par
#include <sys/stat.h>\par
#include <sys/types.h>\par
#include <unistd.h>\par
\par
int main() \{\par
    // File path\par
    const char *filePath = "AI practical/demopy.py";\par
\par
    // Get file information\par
    struct stat fileInfo;\par
    if (stat(filePath, &fileInfo) == -1) \{\par
        printf("Failed to get file information.\\n");\par
        return 1;\par
    \}\par
\par
    // Display last access and modified time\par
    printf("Last Access Time: %s", ctime(&fileInfo.st_atime));\par
    printf("Last Modified Time: %s", ctime(&fileInfo.st_mtime));\par
\par
    return 0;\par
\}\par
//to run *filePath = "enter path of the file ";\par
------------------------------------------------------------------------------------------------------------------------Q\par
// maps a given file in memory and displays the content of the mapped file in reverse:\par
\par
#include <stdio.h>\par
#include <stdlib.h>\par
#include <sys/mman.h>\par
#include <sys/stat.h>\par
#include <fcntl.h>\par
#include <unistd.h>\par
\par
int main(int argc, char *argv[]) \{\par
    if (argc != 2) \{\par
        printf("Please provide the file name as a command line argument.\\n");\par
        return 1;\par
    \}\par
\par
    // Open the file\par
    int file = open(argv[1], O_RDONLY);\par
    if (file == -1) \{\par
        printf("Unable to open the file.\\n");\par
        return 1;\par
    \}\par
\par
    // Get the size of the file\par
    struct stat st;\par
    if (fstat(file, &st) == -1) \{\par
        printf("Unable to get file size.\\n");\par
        close(file);\par
        return 1;\par
    \}\par
    off_t size = st.st_size;\par
\par
    // Map the file into memory\par
    char *fileData = mmap(NULL, size, PROT_READ, MAP_PRIVATE, file, 0);\par
    if (fileData == MAP_FAILED) \{\par
        printf("Unable to map the file into memory.\\n");\par
        close(file);\par
        return 1;\par
    \}\par
\par
    // Print the content of the mapped file in reverse\par
    for (off_t i = size - 1; i >= 0; i--) \{\par
        printf("%c", fileData[i]);\par
    \}\par
\par
    // Unmap the file from memory\par
    munmap(fileData, size);\par
\par
    // Close the file\par
    close(file);\par
\par
    return 0;\par
\}\par
//You can run this program and provide the file name as a command line argument. It will map the file into memory and display its content in reverse. \par
------------------------------------------------------------------------------------------------------------------------Q\par
//set the resource limit for files and memory associated with a process:\par
\par
#include <stdio.h>\par
#include <sys/resource.h>\par
\par
int main() \{\par
    // Get the current resource limit\par
    struct rlimit limit;\par
    getrlimit(RLIMIT_MEMLOCK, &limit);\par
\par
    // Print the current resource limit\par
    printf("The current resource limit for files and memory is: %lu\\n", limit.rlim_cur);\par
\par
    // Set a new resource limit\par
    limit.rlim_cur = 1024 * 1024; // 1MB\par
    setrlimit(RLIMIT_MEMLOCK, &limit);\par
\par
    // Get the updated resource limit\par
    getrlimit(RLIMIT_MEMLOCK, &limit);\par
\par
    // Print the updated resource limit\par
    printf("The updated resource limit for files and memory is: %lu\\n", limit.rlim_cur);\par
\par
    return 0;\par
\}\par
------------------------------------------------------------------------------------------------------------------------Q\par
\par
//creates two files with the specified permissions:\par
#include <stdio.h>\par
#include <sys/types.h>\par
#include <sys/stat.h>\par
#include <fcntl.h>\par
\par
int main() \{\par
    // Create the first file with read and write permissions for owner, group, and other users\par
    int file1 = open("file1.txt", O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\par
    if (file1 == -1) \{\par
        printf("Oops! Unable to create file1.txt.\\n");\par
        return 1;\par
    \}\par
\par
    // Turn on the group-ID and turn off group execute permission for the first file\par
    if (chmod("file1.txt", S_ISGID | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) == -1) \{\par
        printf("Oops! Unable to modify permissions for file1.txt.\\n");\par
        return 1;\par
    \}\par
\par
    // Create the second file with read and write permissions only for the owner\par
    umask(S_IWGRP | S_IROTH | S_IWOTH);\par
    int file2 = open("file2.txt", O_CREAT, S_IRUSR | S_IWUSR);\par
    if (file2 == -1) \{\par
        printf("Oops! Unable to create file2.txt.\\n");\par
        return 1;\par
    \}\par
\par
    // Set the read permission for all users for the second file\par
    if (chmod("file2.txt", S_IRUSR | S_IRGRP | S_IROTH) == -1) \{\par
        printf("Oops! Unable to modify permissions for file2.txt.\\n");\par
        return 1;\par
    \}\par
\par
    printf("Done! Files created with the specified permissions.\\n");\par
\par
    return 0;\par
\}\par
//This program creates two files: file1.txt and file2.txt. The first file has read and write permissions for the owner, group, and other users. The second file has read and write permissions only for the owner. The program then modifies the permissions using the chmod() function.\par
------------------------------------------------------------------------------------------------------------------------Q\par
//type of file where filename is accepted through Command Line.\par
#include<stdio.h>\par
#include<stdlib.h>\par
#include<fcntl.h>\par
#include<unistd.h>\par
#include<sys/stat.h>\par
#include<sys/types.h>\par
#include<dirent.h>\par
int main (int argc, char *argv[])\par
\{\par
struct stat fileStat;\par
char fnm[30];\par
int fd=0;\par
FILE *filename;\par
printf("Enter file name= ");\par
scanf("%s",fnm);\par
if ( ( fd = open (fnm , O_RDONLY) ) == -1)\{\par
perror ( "open " );\par
system("pause");\par
exit (1) ;\par
\}\par
if(fstat(fd, &fileStat)<0) return 1;\par
printf("Information for %s\\n",fnm);\par
// expected filetype syntax here\par
system("pause");\par
return 0;\par
\}\par
------------------------------------------------------------------------------------------------------------------------Q\par
//Write a C program which display the information of a given file similar to given by the unix/linux command on current directory\par
// (1.e file Access permission, file name, file type, User id,group id, file size, file access and modified     time and so on).\par
// DO NOT simply DO NOT simply exec is -1<filenamey or system command from\~the\~program\par
#include <stdio.h>\par
#include <sys/types.h>\par
#include <sys/stat.h>\par
#include <unistd.h>\par
#include <time.h>\par
#include <pwd.h>\par
#include <grp.h>\par
\par
void displayFileInfo(const char *filename) \{\par
    struct stat fileInfo;\par
\par
    // Get file information\par
    if (stat(filename, &fileInfo) == -1) \{\par
        perror("Error in stat");\par
        return;\par
    \}\par
\par
    // Display file information\par
    printf("File Information for: %s\\n", filename);\par
    printf("=====================================\\n");\par
    printf("File type:");\par
\par
    // Check file type\par
    switch (fileInfo.st_mode & S_IFMT) \{\par
        case S_IFREG:\par
            printf("Regular file\\n");\par
            break;\par
        case S_IFDIR:\par
            printf("Directory\\n");\par
            break;\par
        case S_IFLNK:\par
            printf("Symbolic link\\n");\par
            break;\par
        default:\par
            printf("Unknown file type\\n");\par
    \}\par
\par
    printf("File size:=%ld bytes\\n", (long)fileInfo.st_size);\par
    printf("File permissions:=%o\\n", (unsigned int)fileInfo.st_mode & 0777);\par
    printf("User ID:=%d\\n", (int)fileInfo.st_uid);\par
    printf("Group ID:=%d\\n", (int)fileInfo.st_gid);\par
\par
    // Get user and group names\par
    struct passwd *user_info = getpwuid(fileInfo.st_uid);\par
    struct group *group_info = getgrgid(fileInfo.st_gid);\par
\par
    if (user_info != NULL) \{\par
        printf("User name:%s\\n", user_info->pw_name);\par
    \} else \{\par
        printf("User name:Unknown\\n");\par
    \}\par
\par
    if (group_info != NULL) \{\par
        printf("Group name:%s\\n", group_info->gr_name);\par
    \} else \{\par
        printf("Group name:Unknown\\n");\par
    \}\par
\par
    printf("Last access time:%s", ctime(&fileInfo.st_atime));\par
    printf("Last modification time:%s", ctime(&fileInfo.st_mtime));\par
    printf("=====================================\\n");\par
\}\par
\par
int main(int argc, char *argv[]) \{\par
    if (argc != 2) \{\par
        fprintf(stderr, "Usage: %s <filename>\\n", argv[0]);\par
        return 1;\par
    \}\par
\par
    const char *filename = argv[1];\par
    displayFileInfo(filename);\par
\par
    return 0;\par
\}\par
\par
\par
\par
\par
------------------------------------------------------------------------------------------------------------------------\par
Q\par
\par
\par
}
 